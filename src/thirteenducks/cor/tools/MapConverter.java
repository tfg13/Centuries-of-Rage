/*
 *  Copyright 2008, 2009, 2010, 2011:
 *   Tobias Fleig (tfg[AT]online[DOT]de),
 *   Michael Haas (mekhar[AT]gmx[DOT]de),
 *   Johannes Kattinger (johanneskattinger[AT]gmx[DOT]de)
 *
 *  - All rights reserved -
 *
 *
 *  This file is part of Centuries of Rage.
 *
 *  Centuries of Rage is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Centuries of Rage is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Centuries of Rage.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/*
 * MapConverter.java
 *
 * Created on 22.09.2010, 16:31:53
 */
package thirteenducks.cor.tools;

import thirteenducks.cor.map.CoRMap;
import thirteenducks.cor.game.Building;
import thirteenducks.cor.game.Unit;
import thirteenducks.cor.map.CoRMapElement.collision;
import java.awt.Color;
import java.awt.Component;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.ListCellRenderer;
import thirteenducks.cor.game.Position;
import thirteenducks.cor.game.Ressource;
import thirteenducks.cor.map.CoRMapElement;

/**
 *
 * @author tfg
 */
public class MapConverter extends javax.swing.JFrame {

    /** Creates new form MapConverter */
    public MapConverter() {
        initComponents();
        // Listen laden:
        refreshLists();

        // Renderer

        jList1.setCellRenderer(new ListCellRenderer() {

            @Override
            public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
                File f = (File) value;
                JLabel l = new JLabel(f.getName());
                if (isSelected) {
                    l.setForeground(Color.BLACK);
                } else {
                    l.setForeground(Color.LIGHT_GRAY);
                }
                return l;
            }
        });
        jList2.setCellRenderer(new ListCellRenderer() {

            @Override
            public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
                File f = (File) value;
                JLabel l = new JLabel(f.getName());
                if (isSelected) {
                    l.setForeground(Color.BLACK);
                } else {
                    l.setForeground(Color.LIGHT_GRAY);
                }
                return l;
            }
        });

        this.setVisible(true);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jList1 = new javax.swing.JList();
        jScrollPane2 = new javax.swing.JScrollPane();
        jList2 = new javax.swing.JList();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        jLabel4 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setName("CoR:Map_Converter"); // NOI18N
        setResizable(false);
        getContentPane().setLayout(null);

        jLabel1.setFont(new java.awt.Font("Dialog", 1, 14));
        jLabel1.setText("Centuries of Rage Map Converter");
        getContentPane().add(jLabel1);
        jLabel1.setBounds(12, 12, 264, 17);

        jScrollPane1.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        jScrollPane1.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

        jList1.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        jList1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                jList1MouseEntered(evt);
            }
            public void mouseExited(java.awt.event.MouseEvent evt) {
                jList1MouseExited(evt);
            }
        });
        jList1.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
            public void valueChanged(javax.swing.event.ListSelectionEvent evt) {
                jList1ValueChanged(evt);
            }
        });
        jScrollPane1.setViewportView(jList1);

        getContentPane().add(jScrollPane1);
        jScrollPane1.setBounds(12, 68, 177, 131);

        jScrollPane2.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        jScrollPane2.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

        jList2.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        jList2.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        jList2.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                jList2MouseEntered(evt);
            }
            public void mouseExited(java.awt.event.MouseEvent evt) {
                jList2MouseExited(evt);
            }
        });
        jList2.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
            public void valueChanged(javax.swing.event.ListSelectionEvent evt) {
                jList2ValueChanged(evt);
            }
        });
        jScrollPane2.setViewportView(jList2);

        getContentPane().add(jScrollPane2);
        jScrollPane2.setBounds(201, 68, 187, 131);

        jLabel2.setText("Normal Maps");
        getContentPane().add(jLabel2);
        jLabel2.setBounds(12, 47, 92, 15);

        jLabel3.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        jLabel3.setText("Resistant Maps");
        getContentPane().add(jLabel3);
        jLabel3.setBounds(271, 43, 117, 15);

        jButton1.setText("convert to RMAP -->");
        jButton1.setEnabled(false);
        jButton1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                jButton1MouseEntered(evt);
            }
            public void mouseExited(java.awt.event.MouseEvent evt) {
                jButton1MouseExited(evt);
            }
        });
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });
        getContentPane().add(jButton1);
        jButton1.setBounds(12, 205, 177, 25);

        jButton2.setText("<-- convert to NMAP");
        jButton2.setEnabled(false);
        jButton2.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                jButton2MouseEntered(evt);
            }
            public void mouseExited(java.awt.event.MouseEvent evt) {
                jButton2MouseExited(evt);
            }
        });
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });
        getContentPane().add(jButton2);
        jButton2.setBounds(201, 205, 187, 25);

        jLabel4.setFont(new java.awt.Font("Dialog", 0, 12));
        jLabel4.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        getContentPane().add(jLabel4);
        jLabel4.setBounds(10, 240, 380, 20);

        java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
        setBounds((screenSize.width-410)/2, (screenSize.height-296)/2, 410, 296);
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        // Normale Map in eine RMAP umwandeln. Dazu zuerst öffnen:
        // Datei suchen
        File openMapFile = (File) jList1.getSelectedValue();
        // Map laden
        ObjectInputStream objIn = null;
        CoRMap theMap = null;
        ArrayList<Unit> unitList;
        ArrayList<Building> buildingList;
        ArrayList<Ressource> resList;
        int nextNetID;
        try {
            ZipFile zipfile = new ZipFile(openMapFile);
            ZipEntry entry = zipfile.getEntry("MAP");
            objIn = new ObjectInputStream(new BufferedInputStream(zipfile.getInputStream(entry)));
            try {
                theMap = (CoRMap) objIn.readObject();
            } catch (ClassNotFoundException ex) {
                JOptionPane.showMessageDialog(this, "Cannot open map for conversion. Map too old or corrupted.", "Can't convert", JOptionPane.ERROR_MESSAGE);
                return;
            }
            objIn.close();
            unitList = (ArrayList<Unit>) theMap.getMapPoperty("UNIT_LIST");
            buildingList = (ArrayList<Building>) theMap.getMapPoperty("BUILDING_LIST");
            resList = (ArrayList<Ressource>) theMap.getMapPoperty("RES_LIST");
            nextNetID = (Integer) theMap.getMapPoperty("NEXTNETID");
        } catch (ZipException zex) {
            // User versucht nicht-zip Map zu öffnen
            JOptionPane.showMessageDialog(this, "Cannot open map for conversion. Map too old or corrupted.", "Can't convert", JOptionPane.ERROR_MESSAGE);
            return;
        } catch (IOException ex) {
            JOptionPane.showMessageDialog(this, "Cannot open map for conversion. Map too old or corrupted.", "Can't convert", JOptionPane.ERROR_MESSAGE);
            return;
        } finally {
            try {
                objIn.close();
            } catch (IOException ex) {
            }

        }
        // Jetzt wurde die Map geladen. Als nächstes im RMAP-Format abspeichern
        saveRMAP(theMap, unitList, buildingList, resList, nextNetID);
        // Listen neu laden
        refreshLists();
        jLabel4.setText("Done converting into RMAP");
    }//GEN-LAST:event_jButton1ActionPerformed

    private void refreshLists() {
        File mapfolder = new File("map/main");
        File[] nmaps = mapfolder.listFiles(new FilenameFilter() {

            @Override
            public boolean accept(File dir, String name) {
                if (name.contains(".")) {
                    String end = name.substring(name.lastIndexOf("."));
                    return (".map".equals(end) || ".MAP".equals(end));
                }
                return false;
            }
        });
        File[] rmaps = mapfolder.listFiles(new FilenameFilter() {

            @Override
            public boolean accept(File dir, String name) {
                if (name.contains(".")) {
                    String end = name.substring(name.lastIndexOf("."));
                    return (".rmap".equals(end) || ".RMAP".equals(end));
                }
                return false;
            }
        });
        if (nmaps != null) {
            jList1.setListData(nmaps);
        }
        if (rmaps != null) {
            jList2.setListData(rmaps);
        }
    }

    private void jList1ValueChanged(javax.swing.event.ListSelectionEvent evt) {//GEN-FIRST:event_jList1ValueChanged
        // TODO add your handling code here:
        jButton1.setEnabled(jList1.getSelectedValue() != null);
    }//GEN-LAST:event_jList1ValueChanged

    private void jList2ValueChanged(javax.swing.event.ListSelectionEvent evt) {//GEN-FIRST:event_jList2ValueChanged
        // TODO add your handling code here:
        jButton2.setEnabled(jList2.getSelectedValue() != null);
    }//GEN-LAST:event_jList2ValueChanged

    private void jList1MouseEntered(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jList1MouseEntered
        // TODO add your handling code here:
        jLabel4.setText("\"Normal\" maps. Future version of CoR can't read them.");
    }//GEN-LAST:event_jList1MouseEntered

    private void jList2MouseEntered(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jList2MouseEntered
        // TODO add your handling code here:
        jLabel4.setText("RMAPS: Cannot be used directly, but will \"survive\" updates");
    }//GEN-LAST:event_jList2MouseEntered

    private void jList2MouseExited(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jList2MouseExited
        jLabel4.setText("");
    }//GEN-LAST:event_jList2MouseExited

    private void jList1MouseExited(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jList1MouseExited
        jLabel4.setText("");
    }//GEN-LAST:event_jList1MouseExited

    private void jButton1MouseEntered(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jButton1MouseEntered
        jLabel4.setText("Click here to convert the selected NMAP into an RMAP");
    }//GEN-LAST:event_jButton1MouseEntered

    private void jButton2MouseEntered(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jButton2MouseEntered
        jLabel4.setText("Click here to convert the selected RMAP into an NMAP");
    }//GEN-LAST:event_jButton2MouseEntered

    private void jButton2MouseExited(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jButton2MouseExited
        jLabel4.setText("");
    }//GEN-LAST:event_jButton2MouseExited

    private void jButton1MouseExited(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jButton1MouseExited
        jLabel4.setText("");
    }//GEN-LAST:event_jButton1MouseExited

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        try {
            // RMAP lesen und zurück in NMAP verwandeln
            // Datei öffnen und Infozeile lesen:
            BufferedReader reader = new BufferedReader(new FileReader((File) jList2.getSelectedValue()));
            String infoline = reader.readLine();
            // Die Infozeile enthält (in dieser Reihenfolge): X Y unitList.size() buildingList.size() resList.size() nextNetID
            // Rauslesen
            String[] data = infoline.split(" ");
            int newMapX = Integer.parseInt(data[0]);
            int newMapY = Integer.parseInt(data[1]);
            int uS = Integer.parseInt(data[2]);
            int bS = Integer.parseInt(data[3]);
            int rS = Integer.parseInt(data[4]);
            int nnid = Integer.parseInt(data[5]);
            // DESC-Settings lesen:
            // Einglesen, normal weitermachen.

            ArrayList<File> olist = new ArrayList<File>();
            ArrayList<File> flist = new ArrayList<File>();
            ArrayList<File> dlist = new ArrayList<File>();

            File OrdnerSuchen = new File("game/"); //Unterordner in "game" suchen
            File[] Ordner = OrdnerSuchen.listFiles();
            for (File ord : Ordner) {
                if (ord.isDirectory() && !ord.getName().startsWith(".") && !ord.getName().startsWith(".")) {
                    olist.add(ord);
                }
            }

            for (int i = 0; i < olist.size(); i++) { //Dateien in den Unterordnern suchen
                String Unterordner = olist.get(i).toString();
                File gameOrdner = new File(Unterordner);
                File[] files = gameOrdner.listFiles();
                for (File file : files) {
                    flist.add(file);
                }
            }

            for (int i = 0; i < flist.size(); i++) {
                File file = flist.get(i);
                if (file.getName().endsWith("~") || file.getName().startsWith(".")) { // Sicherungsdateien und unsichtbares Aussortieren
                    flist.remove(i);
                    i--;
                } else {
                    if (file.getName().startsWith("d") || file.getName().startsWith("D")) {
                        dlist.add(file);
                    }
                }
            }

            HashMap<Integer, Unit> descTypeUnit = new HashMap<Integer, Unit>();
            HashMap<Integer, Building> descTypeBuilding = new HashMap<Integer, Building>();

            for (File descFile : dlist) {
                // Read game/descTypes
                FileReader descReader = null;
                try {
                    descReader = new FileReader(descFile);
                    BufferedReader bdescReader = new BufferedReader(descReader);
                    String zeile = null;
                    // Einlesen
                    boolean inDesc = false;
                    String mode = null;
                    Building rB = null;
                    Unit rU = null;
                    int id = 0;
                    int line = 0;
                    while ((zeile = bdescReader.readLine()) != null) {
                        line++;
                        // Zeile interpretieren
                        if (!zeile.isEmpty()) {
                            char first = zeile.charAt(0);
                            if (first == '#') {
                                // Kommentar, ignorieren
                                continue;
                            }

                            // Sind wir grad in der Klammer ?
                            if (inDesc) {
                                // Beim = trennen
                                int indexgleich = zeile.indexOf('='); // Istgleich suchen
                                if (indexgleich != -1) {
                                    String v1 = zeile.substring(0, indexgleich);
                                    String v2 = zeile.substring(indexgleich + 1);
                                    int indexraute = v2.indexOf('#'); //Kommentar am Ende der Zeile?
                                    if (indexraute != -1) {
                                        v2 = v2.substring(0, indexraute - 1);
                                    }
                                    if (mode.equals("B")) {
                                        // Gebäude
                                        if (v1.equals("name")) {
                                            rB.name = v2;
                                        } else if (v1.equals("defaultTexture")) {
                                            rB.defaultTexture = v2;
                                        } else if (v1.equals("hitpoints")) {
                                            rB.hitpoints = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("maxhitpoints")) {
                                            rB.maxhitpoints = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("Gdesc")) {
                                            rB.Gdesc = v2;
                                        } else if (v1.equals("Gimg")) {
                                            rB.Gimg = v2;
                                        } else if (v1.equals("offsetX")) {
                                            rB.offsetX = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("offsetY")) {
                                            rB.offsetY = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("z1")) {
                                            rB.z1 = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("z2")) {
                                            rB.z2 = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("maxIntra")) {
                                            rB.maxIntra = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("harvests")) {
                                            rB.harvests = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("harvRate")) {
                                            rB.harvRate = saveStrtoDouble(v2, zeile, line);
                                        } else if (v1.equals("damage")) {
                                            rB.damage = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("cooldownmax")) {
                                            rB.cooldownmax = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("range")) {
                                            rB.range = saveStrtoDouble(v2, zeile, line);
                                        } else if (v1.equals("bulletspeed")) {
                                            rB.bulletspeed = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("atkdelay")) {
                                            rB.atkdelay = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("antiair")) {
                                            rB.antiair = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("antibuilding")) {
                                            rB.antibuilding = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("antiheavyinf")) {
                                            rB.antiheavyinf = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("antikav")) {
                                            rB.antikav = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("antilightinf")) {
                                            rB.antilightinf = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("antitank")) {
                                            rB.antitank = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("antivehicle")) {
                                            rB.antivehicle = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("accepts")) {
                                            if ("all".equals(v2)) {
                                                rB.accepts = Building.ACCEPTS_ALL;
                                            }
                                        }/* else if (v1.equals("ability")) {
                                        RogGameObjectAbility ra = clientDescAbilities.get(new Integer(saveStrtoInt(v2, zeile, line)));
                                        if (ra != null) {
                                        rB.abilitys.add(ra);
                                        }
                                        }*/
                                    } else if (mode.equals("U")) {
                                        // Einheiten
                                        if (v1.equals("name")) {
                                            rU.name = v2;
                                        } else if (v1.equals("defaultTexture")) {
                                            rU.graphicsdata.defaultTexture = v2;
                                        } else if (v1.equals("hitpoints")) {
                                            rU.hitpoints = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("maxhitpoints")) {
                                            rU.maxhitpoints = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("Gdesc")) {
                                            rU.Gdesc = v2;
                                        } else if (v1.equals("Gimg")) {
                                            rU.Gimg = v2;
                                        } else if (v1.equals("Gpro")) {
                                            rU.Gpro = v2;
                                        } else if (v1.equals("Gcon")) {
                                            rU.Gcon = v2;
                                        } else if (v1.equals("speed")) {
                                            rU.speed = saveStrtoDouble(v2, zeile, line);
                                        } else if (v1.equals("range")) {
                                            rU.range = saveStrtoDouble(v2, zeile, line);
                                        } else if (v1.equals("damage")) {
                                            rU.damage = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("cooldownmax")) {
                                            rU.cooldownmax = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("bulletspeed")) {
                                            rU.bulletspeed = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("atkdelay")) {
                                            rU.atkdelay = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("armortype")) {
                                            rU.armortype = v2;
                                        } else if (v1.equals("antiheavyinf")) {
                                            rU.antiheavyinf = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("antilightinf")) {
                                            rU.antilightinf = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("antikav")) {
                                            rU.antikav = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("antivehicle")) {
                                            rU.antivehicle = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("antitank")) {
                                            rU.antitank = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("antiair")) {
                                            rU.antiair = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("antibuilding")) {
                                            rU.antibuilding = saveStrtoInt(v2, zeile, line);
                                        } else if (v1.equals("idlerange")) {
                                            rU.idlerange = saveStrtoDouble(v2, zeile, line);
                                        } /*else if (v1.equals("ability")) {
                                        RogGameObjectAbility ra = clientDescAbilities.get(new Integer(saveStrtoInt(v2, zeile, line)));
                                        if (ra != null) {
                                        rU.abilitys.add(ra);
                                        }
                                        } */ else if ("harvester".equals(v1)) {
                                            // Einheit kann ernten:
                                            rU.canHarvest = true;
                                        }

                                    }
                                }
                            }

                            if (first == 'U') {
                                // Neue Einheit
                                rU = new Unit(0, 0, -1);
                                inDesc = true;
                                int indexL1 = zeile.indexOf(" ");
                                int indexL2 = zeile.lastIndexOf(" ");
                                String v3 = zeile.substring(indexL1 + 1, indexL2);
                                id = Integer.parseInt(v3);
                                mode = "U";
                            } else if (first == 'B') {
                                // Neues Gebäude
                                rB = new Building(0, 0, -1);
                                inDesc = true;
                                int indexL1 = zeile.indexOf(" ");
                                int indexL2 = zeile.lastIndexOf(" ");
                                String v3 = zeile.substring(indexL1 + 1, indexL2);
                                id = Integer.parseInt(v3);
                                mode = "B";
                            } else if (first == '}') {
                                // Fertig, in HashMap speichern
                                if (mode.equals("U")) {
                                    rU.descTypeId = id;
                                    descTypeUnit.put(id, rU);
                                    inDesc = false;
                                } else if (mode.equals("B")) {
                                    rB.descTypeId = id;
                                    descTypeBuilding.put(id, rB);
                                    inDesc = false;
                                }
                            }
                        }
                    }
                } catch (FileNotFoundException ex) {
                    ex.printStackTrace();
                } catch (IOException ex) {
                    ex.printStackTrace();
                } finally {
                    try {
                        descReader.close();
                    } catch (IOException ex) {
                    }
                }
            }
            // Leere Map im Speicher anlegen

            CoRMapElement[][] newMapArray = new CoRMapElement[newMapX][newMapY];
            for (int x = 0; x < newMapX; x++) {
                for (int y = 0; y < newMapY; y++) {
                    if (x % 2 == y % 2) {
                        newMapArray[x][y] = new CoRMapElement();
                    }
                }
            }

            String newMapName = ((File) jList2.getSelectedValue()).getName();
            // Die Endung des Mapnamens entfernen
            newMapName = newMapName.substring(0, newMapName.lastIndexOf("."));
            CoRMap map = new CoRMap(newMapX, newMapY, newMapName, newMapArray);

            ArrayList<Unit> unitList = new ArrayList<Unit>();
            map.setMapProperty("UNIT_LIST", unitList);
            ArrayList<Building> buildingList = new ArrayList<Building>();
            map.setMapProperty("BUILDING_LIST", buildingList);
            ArrayList<Ressource> resList = new ArrayList<Ressource>();
            map.setMapProperty("RES_LIST", resList);


            // Jetzt alles einlesen. Als erstes die ground_tex
            for (int x = 0; x < newMapX; x++) {
                for (int y = 0; y < newMapY; y++) {
                    if (x % 2 != y % 2) {
                        continue;
                    }
                    String val = reader.readLine();
                    if (!"".equals(val)) {
                        map.changeElementProperty(x, y, "ground_tex", val);
                    }
                }
            }
            // fix_tex
            for (int x = 0; x < newMapX; x++) {
                for (int y = 0; y < newMapY; y++) {
                    if (x % 2 != y % 2) {
                        continue;
                    }
                    String val = reader.readLine();
                    if (!"".equals(val)) {
                        map.changeElementProperty(x, y, "fix_tex", val);
                    }
                }
            }
            // Kollision
            for (int x = 0; x < newMapX; x++) {
                for (int y = 0; y < newMapY; y++) {
                    if (x % 2 != y % 2) {
                        continue;
                    }
                    String read = reader.readLine();
                    if ("free".equals(read)) {
                        map.visMap[x][y].collision = collision.free;
                    } else if ("blocked".equals(read)) {
                        map.visMap[x][y].collision = collision.blocked;
                    } else if ("occupied".equals(read)) {
                        map.visMap[x][y].collision = collision.occupied;
                    }
                }
            }

            // Units

            for (int i = 1; i <= uS; i++) {
                String[] unitData = reader.readLine().split(" ");
                int desc = Integer.parseInt(unitData[0]);
                String pos = unitData[1];
                int x = Integer.parseInt(pos.substring(0, pos.indexOf("|")));
                int y = Integer.parseInt(pos.substring(pos.indexOf("|") + 1, pos.length()));
                int playerId = Integer.parseInt(unitData[2]);
                int netId = Integer.parseInt(unitData[3]);
                Unit unit = null;
                try {
                    unit = descTypeUnit.get(desc).clone(netId);
                } catch (CloneNotSupportedException ex) {
                    ex.printStackTrace();
                }
                unit.setPlayerId(playerId);
                unit.position = new Position(x, y);
                unitList.add(unit);
            }

            // Gebäude

            for (int i = 1; i <= bS; i++) {
                String[] unitData = reader.readLine().split(" ");
                int desc = Integer.parseInt(unitData[0]);
                String pos = unitData[1];
                int x = Integer.parseInt(pos.substring(0, pos.indexOf("|")));
                int y = Integer.parseInt(pos.substring(pos.indexOf("|") + 1, pos.length()));
                int playerId = Integer.parseInt(unitData[2]);
                int netId = Integer.parseInt(unitData[3]);
                Building b = null;
                try {
                    b = descTypeBuilding.get(desc).clone(netId);
                } catch (CloneNotSupportedException ex) {
                    ex.printStackTrace();
                }
                b.setPlayerId(playerId);
                b.position = new Position(x, y);
                buildingList.add(b);
            }

            // Gebäude

            for (int i = 1; i <= rS; i++) {
                String[] unitData = reader.readLine().split(" ", 4);
                int type = Integer.parseInt(unitData[0]);
                String pos = unitData[1];
                int x = Integer.parseInt(pos.substring(0, pos.indexOf("|")));
                int y = Integer.parseInt(pos.substring(pos.indexOf("|") + 1, pos.length()));
                int netId = Integer.parseInt(unitData[2]);
                String tex = unitData[3];
                Ressource r = new thirteenducks.cor.game.Ressource(type, tex, netId);
                r.position = new Position(x, y);
                resList.add(r);
            }

            // Grenzen der Map mit Kollision und isborder ausstatten
            for (int x = 0; x < newMapX; x++) {
                for (int y = 0; y < newMapY; y++) {
                    if (x % 2 != y % 2) {
                        continue;
                    }
                    if (x == 0 || x == (newMapX - 1) || y == 0 || y == (newMapY - 1)) {
                        // Feld hat Kollision
                        map.changeElementProperty(x, y, "is_border", "true");
                        map.visMap[x][y].setCollision(collision.blocked);
                    }
                }
            }

            map.setMapProperty("NEXTNETID", nnid);
            saveNMAP(map);


        } catch (FileNotFoundException ex) {
            ex.printStackTrace();
        } catch (IOException ex2) {
            ex2.printStackTrace();
        }


    }//GEN-LAST:event_jButton2ActionPerformed

    public void saveNMAP(CoRMap RandomRogMap) { // Speichert die Map ab
        // Datei anlegen
        File newMapSaver = new File(RandomRogMap.getPath());
        if (newMapSaver.exists()) {
            int result = JOptionPane.showConfirmDialog(this, "NMAP exists, overwrite?", "MAPCONV: Warning", JOptionPane.YES_NO_OPTION);
            if (result == JOptionPane.NO_OPTION) {
                return;
            }
        }
        try {
            // Map serialisieren und speichern
            ZipOutputStream zipOut = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(newMapSaver)));
            ZipEntry entry = new ZipEntry("MAP");
            zipOut.putNextEntry(entry);
            ObjectOutputStream objOut = new ObjectOutputStream(zipOut);
            objOut.writeObject(RandomRogMap);
            zipOut.closeEntry();
            objOut.close();
        } catch (FileNotFoundException ex) {
            ex.printStackTrace();
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    /**
     * Speichert eine Map im RMAP-Format
     * @param map
     * @param unitList
     * @param buildingList
     * @param resList
     * @param nextNetID
     */
    private void saveRMAP(CoRMap map, ArrayList<Unit> unitList, ArrayList<Building> buildingList, ArrayList<Ressource> resList, int nextNetID) {
        // Datei anlegen
        File file = new File("map/main/" + map.mapName + ".rmap");
        if (file.exists()) {
            int result = JOptionPane.showConfirmDialog(this, "RMAP exists, overwrite?", "MAPCONV: Warning", JOptionPane.YES_NO_OPTION);
            if (result == JOptionPane.NO_OPTION) {
                return;
            }
        }
        try {
            BufferedWriter writer = new java.io.BufferedWriter(new java.io.FileWriter(file, false));
            // Zuerst ints, nach folgender Systax: X Y unitList.size() buildingList.size() resList.size() nextNetID
            writer.write(map.getMapSizeX() + " " + map.getMapSizeY() + " " + unitList.size() + " " + buildingList.size() + " " + resList.size() + " " + nextNetID);
            writer.newLine();
            // Jetzt die Bodentexturen
            for (int x = 0; x < map.getMapSizeX(); x++) {
                for (int y = 0; y < map.getMapSizeY(); y++) {
                    if (x % 2 != y % 2) {
                        continue;
                    }
                    String val = map.getElementProperty(x, y, "ground_tex");
                    if (val != null) {
                        writer.write(val);
                    }
                    writer.newLine();
                }
            }
            // Fix
            // Jetzt die Bodentexturen
            for (int x = 0; x < map.getMapSizeX(); x++) {
                for (int y = 0; y < map.getMapSizeY(); y++) {
                    if (x % 2 != y % 2) {
                        continue;
                    }
                    String val = map.getElementProperty(x, y, "fix_tex");
                    if (val != null) {
                        writer.write(val);
                    }
                    writer.newLine();
                }
            }
            // Kollision
            for (int x = 0; x < map.getMapSizeX(); x++) {
                for (int y = 0; y < map.getMapSizeY(); y++) {
                    if (x % 2 != y % 2) {
                        continue;
                    }
                    thirteenducks.cor.map.CoRMapElement.collision col = map.visMap[x][y].getCollision();
                    if (col != null) {
                        writer.write(col.toString());
                    }
                    writer.newLine();
                }
            }
            // Einheiten
            for (Unit unit : unitList) {
                writer.write(unit.descTypeId + " " + unit.position + " " + unit.playerId + " " + unit.netID);
                writer.newLine();
            }
            // Gebäude
            for (Building building : buildingList) {
                writer.write(building.descTypeId + " " + building.position + " " + building.playerId + " " + building.netID);
                writer.newLine();
            }
            // Ressourcen
            for (Ressource res : resList) {
                writer.write(res.getType() + " " + res.position + " " + res.netID + " " + res.getTex());
                writer.newLine();
            }
            // Fertig
            writer.flush();
            writer.close();
        } catch (IOException ex) {
            return;
        }
    }

    private int saveStrtoInt(String transform, String ganzeZeile, int line) {
        // Übersetzt den String in ein int und fängt exceptions ab.
        int i;
        try {
            i = Integer.parseInt(transform);
            return i;
        } catch (java.lang.NumberFormatException ex) {
            return 1;
        }
    }

    private double saveStrtoDouble(String transform, String ganzeZeile, int line) {
        // Übersetzt den String in ein int und fängt exceptions ab.
        double i;
        try {
            i = Double.parseDouble(transform);
            return i;
        } catch (java.lang.NumberFormatException ex) {
            return 1;
        }
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JList jList1;
    private javax.swing.JList jList2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    // End of variables declaration//GEN-END:variables
}
